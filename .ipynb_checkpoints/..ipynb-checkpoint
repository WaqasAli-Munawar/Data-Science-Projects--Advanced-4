{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "PyTorch is a library in Python which provides tools to build deep learning models. \n",
    "* What python does for programming, PyTorch does for deep learning. \n",
    "* Python is a very flexible language for programming and just like python, the PyTorch library provides flexible tools for deep learning. \n",
    "\n",
    "If we are learning deep learning or looking to start with it, then the knowledge of PyTorch will help us a lot in creating our deep learning models."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "It has proven to be one of the most flexible and stronger tools to work with real-world problems by providing a higher level of performance. PyTorch provides a deep data structure known as a tensor, which is a multidimensional array that facilitates many similarities with the NumPy arrays.\n",
    "\n",
    "### Why PyTorch for Deep Learning?\n",
    "As we know deep learning allows us to work with a very wide range of complicated tasks, like machine translations, playing strategy games, objects detection, and many more. With PyTorch, we can perform these complex tasks in very flexible ways. Now let’s understand PyTorch more by working on a real-world example.\n",
    "\n",
    "### Training a Classifier with PyTorch\n",
    "We will do the following steps in order to work on the Image Classification with PyTorch:\n",
    "\n",
    "1. Load and normalizing the CIFAR10 training and test datasets using torchvision\n",
    "2. Define a Convolutional Neural Network\n",
    "3. Define a loss function\n",
    "4. Train the network on the training data\n",
    "5. Test the network on the test data\n",
    "6. Loading and normalizing CIFAR10.\n",
    "7. Using torchvision, it’s very easy to load CIFAR10:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import torch\n",
    "import torchvision\n",
    "import torchvision.transforms as transforms"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "The output of torchvision datasets are PILImage images of range `[0, 1]`. We transform them to Tensors of normalized range `[-1, 1]`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "transform = transforms.Compose(\n",
    "    [transforms.ToTensor(),\n",
    "     transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))])"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Downloading https://www.cs.toronto.edu/~kriz/cifar-10-python.tar.gz to ./data\\cifar-10-python.tar.gz\n"
     ]
    },
    {
     "data": {
      "application/vnd.jupyter.widget-view+json": {
       "model_id": "b9100b1aecb44c0d99a422c19629d658",
       "version_major": 2,
       "version_minor": 0
      },
      "text/plain": [
       "HBox(children=(FloatProgress(value=0.0, max=170498071.0), HTML(value='')))"
      ]
     },
     "metadata": {},
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "\n",
      "Extracting ./data\\cifar-10-python.tar.gz to ./data\n",
      "Files already downloaded and verified\n"
     ]
    }
   ],
   "source": [
    "trainset = torchvision.datasets.CIFAR10(root='./data', train=True,\n",
    "                                        download=True, transform=transform)\n",
    "trainloader = torch.utils.data.DataLoader(trainset, batch_size=4,\n",
    "                                          shuffle=True, num_workers=2)\n",
    "\n",
    "testset = torchvision.datasets.CIFAR10(root='./data', train=False,\n",
    "                                       download=True, transform=transform)\n",
    "testloader = torch.utils.data.DataLoader(testset, batch_size=4,\n",
    "                                         shuffle=False, num_workers=2)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "classes = ('plane', 'car', 'bird', 'cat',\n",
    "           'deer', 'dog', 'frog', 'horse', 'ship', 'truck')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now let’s have a look at some of our training images:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "horse   cat   cat   car\n"
     ]
    }
   ],
   "source": [
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "\n",
    "# functions to show an image\n",
    "\n",
    "\n",
    "def imshow(img):\n",
    "    img = img / 2 + 0.5     # unnormalize\n",
    "    npimg = img.numpy()\n",
    "    plt.imshow(np.transpose(npimg, (1, 2, 0)))\n",
    "    plt.show()\n",
    "\n",
    "\n",
    "# get some random training images\n",
    "dataiter = iter(trainloader)\n",
    "images, labels = dataiter.next()\n",
    "\n",
    "# show images\n",
    "imshow(torchvision.utils.make_grid(images))\n",
    "# print labels\n",
    "print(' '.join('%5s' % classes[labels[j]] for j in range(4)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "metadata": {},
   "outputs": [],
   "source": [
    "# define a Convolutional Neural Network using PyTorch:\n",
    "\n",
    "import torch.nn as nn\n",
    "import torch.nn.functional as F\n",
    "\n",
    "\n",
    "class Net(nn.Module):\n",
    "    def __init__(self):\n",
    "        super(Net, self).__init__()\n",
    "        self.conv1 = nn.Conv2d(3, 6, 5)\n",
    "        self.pool = nn.MaxPool2d(2, 2)\n",
    "        self.conv2 = nn.Conv2d(6, 16, 5)\n",
    "        self.fc1 = nn.Linear(16 * 5 * 5, 120)\n",
    "        self.fc2 = nn.Linear(120, 84)\n",
    "        self.fc3 = nn.Linear(84, 10)\n",
    "\n",
    "    def forward(self, x):\n",
    "        x = self.pool(F.relu(self.conv1(x)))\n",
    "        x = self.pool(F.relu(self.conv2(x)))\n",
    "        x = x.view(-1, 16 * 5 * 5)\n",
    "        x = F.relu(self.fc1(x))\n",
    "        x = F.relu(self.fc2(x))\n",
    "        x = self.fc3(x)\n",
    "        return x\n",
    "\n",
    "\n",
    "net = Net()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now we will define a loss function using a Classification cross-Entropy loss and SGD with momentum:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "metadata": {},
   "outputs": [],
   "source": [
    "import torch.optim as optim\n",
    "\n",
    "criterion = nn.CrossEntropyLoss()\n",
    "optimizer = optim.SGD(net.parameters(), lr=0.001, momentum=0.9)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Lets train the Neural Network. Here we will simply loop over our data iterator, and feed the inputs to the neural network to optimize classification:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 9,
   "metadata": {},
   "outputs": [
    {
     "ename": "BrokenPipeError",
     "evalue": "[Errno 32] Broken pipe",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mBrokenPipeError\u001b[0m                           Traceback (most recent call last)",
      "\u001b[1;32m<ipython-input-9-8e82031cfffb>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[0;32m      2\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      3\u001b[0m     \u001b[0mrunning_loss\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;36m0.0\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 4\u001b[1;33m     \u001b[1;32mfor\u001b[0m \u001b[0mi\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mdata\u001b[0m \u001b[1;32min\u001b[0m \u001b[0menumerate\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mtrainloader\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;36m0\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      5\u001b[0m         \u001b[1;31m# get the inputs; data is a list of [inputs, labels]\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      6\u001b[0m         \u001b[0minputs\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mlabels\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mdata\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mC:\\ProgramData\\Anaconda3\\lib\\site-packages\\torch\\utils\\data\\dataloader.py\u001b[0m in \u001b[0;36m__iter__\u001b[1;34m(self)\u001b[0m\n\u001b[0;32m    350\u001b[0m             \u001b[1;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_iterator\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    351\u001b[0m         \u001b[1;32melse\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 352\u001b[1;33m             \u001b[1;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_get_iterator\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    353\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    354\u001b[0m     \u001b[1;33m@\u001b[0m\u001b[0mproperty\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mC:\\ProgramData\\Anaconda3\\lib\\site-packages\\torch\\utils\\data\\dataloader.py\u001b[0m in \u001b[0;36m_get_iterator\u001b[1;34m(self)\u001b[0m\n\u001b[0;32m    292\u001b[0m             \u001b[1;32mreturn\u001b[0m \u001b[0m_SingleProcessDataLoaderIter\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    293\u001b[0m         \u001b[1;32melse\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 294\u001b[1;33m             \u001b[1;32mreturn\u001b[0m \u001b[0m_MultiProcessingDataLoaderIter\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    295\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    296\u001b[0m     \u001b[1;33m@\u001b[0m\u001b[0mproperty\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mC:\\ProgramData\\Anaconda3\\lib\\site-packages\\torch\\utils\\data\\dataloader.py\u001b[0m in \u001b[0;36m__init__\u001b[1;34m(self, loader)\u001b[0m\n\u001b[0;32m    799\u001b[0m             \u001b[1;31m#     before it starts, and __del__ tries to join but will get:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    800\u001b[0m             \u001b[1;31m#     AssertionError: can only join a started process.\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 801\u001b[1;33m             \u001b[0mw\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mstart\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    802\u001b[0m             \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_index_queues\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mappend\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mindex_queue\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    803\u001b[0m             \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_workers\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mappend\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mw\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mC:\\ProgramData\\Anaconda3\\lib\\multiprocessing\\process.py\u001b[0m in \u001b[0;36mstart\u001b[1;34m(self)\u001b[0m\n\u001b[0;32m    110\u001b[0m                \u001b[1;34m'daemonic processes are not allowed to have children'\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    111\u001b[0m         \u001b[0m_cleanup\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 112\u001b[1;33m         \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_popen\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_Popen\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    113\u001b[0m         \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_sentinel\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_popen\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0msentinel\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    114\u001b[0m         \u001b[1;31m# Avoid a refcycle if the target function holds an indirect\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mC:\\ProgramData\\Anaconda3\\lib\\multiprocessing\\context.py\u001b[0m in \u001b[0;36m_Popen\u001b[1;34m(process_obj)\u001b[0m\n\u001b[0;32m    221\u001b[0m     \u001b[1;33m@\u001b[0m\u001b[0mstaticmethod\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    222\u001b[0m     \u001b[1;32mdef\u001b[0m \u001b[0m_Popen\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mprocess_obj\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 223\u001b[1;33m         \u001b[1;32mreturn\u001b[0m \u001b[0m_default_context\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mget_context\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mProcess\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_Popen\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mprocess_obj\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    224\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    225\u001b[0m \u001b[1;32mclass\u001b[0m \u001b[0mDefaultContext\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mBaseContext\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mC:\\ProgramData\\Anaconda3\\lib\\multiprocessing\\context.py\u001b[0m in \u001b[0;36m_Popen\u001b[1;34m(process_obj)\u001b[0m\n\u001b[0;32m    320\u001b[0m         \u001b[1;32mdef\u001b[0m \u001b[0m_Popen\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mprocess_obj\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    321\u001b[0m             \u001b[1;32mfrom\u001b[0m \u001b[1;33m.\u001b[0m\u001b[0mpopen_spawn_win32\u001b[0m \u001b[1;32mimport\u001b[0m \u001b[0mPopen\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 322\u001b[1;33m             \u001b[1;32mreturn\u001b[0m \u001b[0mPopen\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mprocess_obj\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    323\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    324\u001b[0m     \u001b[1;32mclass\u001b[0m \u001b[0mSpawnContext\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mBaseContext\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mC:\\ProgramData\\Anaconda3\\lib\\multiprocessing\\popen_spawn_win32.py\u001b[0m in \u001b[0;36m__init__\u001b[1;34m(self, process_obj)\u001b[0m\n\u001b[0;32m     87\u001b[0m             \u001b[1;32mtry\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     88\u001b[0m                 \u001b[0mreduction\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mdump\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mprep_data\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mto_child\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m---> 89\u001b[1;33m                 \u001b[0mreduction\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mdump\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mprocess_obj\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mto_child\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m     90\u001b[0m             \u001b[1;32mfinally\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     91\u001b[0m                 \u001b[0mset_spawning_popen\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;32mNone\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32mC:\\ProgramData\\Anaconda3\\lib\\multiprocessing\\reduction.py\u001b[0m in \u001b[0;36mdump\u001b[1;34m(obj, file, protocol)\u001b[0m\n\u001b[0;32m     58\u001b[0m \u001b[1;32mdef\u001b[0m \u001b[0mdump\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mobj\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mfile\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mprotocol\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;32mNone\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     59\u001b[0m     \u001b[1;34m'''Replacement for pickle.dump() using ForkingPickler.'''\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m---> 60\u001b[1;33m     \u001b[0mForkingPickler\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mfile\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mprotocol\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mdump\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mobj\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m     61\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     62\u001b[0m \u001b[1;31m#\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mBrokenPipeError\u001b[0m: [Errno 32] Broken pipe"
     ]
    }
   ],
   "source": [
    "for epoch in range(2):  # loop over the dataset multiple times\n",
    "\n",
    "    running_loss = 0.0\n",
    "    for i, data in enumerate(trainloader, 0):\n",
    "        # get the inputs; data is a list of [inputs, labels]\n",
    "        inputs, labels = data\n",
    "\n",
    "        # zero the parameter gradients\n",
    "        optimizer.zero_grad()\n",
    "\n",
    "        # forward + backward + optimize\n",
    "        outputs = net(inputs)\n",
    "        loss = criterion(outputs, labels)\n",
    "        loss.backward()\n",
    "        optimizer.step()\n",
    "\n",
    "        # print statistics\n",
    "        running_loss += loss.item()\n",
    "        if i % 2000 == 1999:    # print every 2000 mini-batches\n",
    "            print('[%d, %5d] loss: %.3f' %\n",
    "                  (epoch + 1, i + 1, running_loss / 2000))\n",
    "            running_loss = 0.0\n",
    "\n",
    "print('Finished Training')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# before moving forward let’s quickly save our model:\n",
    "\n",
    "PATH = './cifar_net.pth'\n",
    "torch.save(net.state_dict(), PATH)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Lets test our trained Neural Network on the test data. But we need to check if the network has learnt anything at all. We will check this by predicting the class label that the neural network outputs, and checking it against the ground-truth. If the prediction is correct, we add the sample to the list of correct predictions."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "dataiter = iter(testloader)\n",
    "images, labels = dataiter.next()\n",
    "\n",
    "# print images\n",
    "imshow(torchvision.utils.make_grid(images))\n",
    "print('GroundTruth: ', ' '.join('%5s' % classes[labels[j]] for j in range(4)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# load our saved model:\n",
    "\n",
    "net = Net()\n",
    "net.load_state_dict(torch.load(PATH))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# let us see what our trained neural network thinks these examples above are:\n",
    "\n",
    "outputs = net(images)\n",
    "_, predicted = torch.max(outputs, 1)\n",
    "\n",
    "print('Predicted: ', ' '.join('%5s' % classes[predicted[j]]\n",
    "                              for j in range(4)))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# lets have a look at the accuracy of our trained neural network:\n",
    "\n",
    "correct = 0\n",
    "total = 0\n",
    "with torch.no_grad():\n",
    "    for data in testloader:\n",
    "        images, labels = data\n",
    "        outputs = net(images)\n",
    "        _, predicted = torch.max(outputs.data, 1)\n",
    "        total += labels.size(0)\n",
    "        correct += (predicted == labels).sum().item()\n",
    "\n",
    "print('Accuracy of the network on the 10000 test images: %d %%' % (\n",
    "    100 * correct / total))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now, lets look deeply on this accuracy rate. We want to see here what classes performed well and what not. We mean to say let’s have a look at the classes which contributed the most and least on this accuracy rate:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "class_correct = list(0. for i in range(10))\n",
    "class_total = list(0. for i in range(10))\n",
    "with torch.no_grad():\n",
    "    for data in testloader:\n",
    "        images, labels = data\n",
    "        outputs = net(images)\n",
    "        _, predicted = torch.max(outputs, 1)\n",
    "        c = (predicted == labels).squeeze()\n",
    "        for i in range(4):\n",
    "            label = labels[i]\n",
    "            class_correct[label] += c[i].item()\n",
    "            class_total[label] += 1\n",
    "\n",
    "\n",
    "for i in range(10):\n",
    "    print('Accuracy of %5s : %2d %%' % (\n",
    "        classes[i], 100 * class_correct[i] / class_total[i]))"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
